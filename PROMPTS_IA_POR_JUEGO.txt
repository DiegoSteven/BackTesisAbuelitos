================================================================================
        RESUMEN DE PROMPTS Y AN√ÅLISIS DE IA POR JUEGO
================================================================================

Este documento describe los prompts enviados a la IA (Gemini) y c√≥mo se 
procesan las respuestas JSON para cada uno de los 4 juegos cognitivos.

================================================================================
üéØ JUEGO 1: PASEO VIRTUAL (ATRAPA LA ESFERA)
================================================================================

MODELO IA UTILIZADO: Gemini 2.5 Flash

USO DE IA: 
- La IA se invoca SOLO cuando el jugador pierde en nivel DIF√çCIL
- Para otros niveles usa l√≥gica determinista simple (sin costo de tokens)

--------------------------------------------------------------------------------
PROMPT ENVIADO A GEMINI
--------------------------------------------------------------------------------

Contexto: "Eres un terapeuta cognitivo. Analiza el rendimiento de un adulto 
mayor en nivel DIFICIL"

DATOS ENVIADOS:
- √öLTIMA SESI√ìN DIF√çCIL:
  * Aciertos: X/Meta
  * Porcentaje de aciertos
  
- HISTORIAL (√∫ltimas 3 sesiones DIF√çCIL):
  * Total de intentos
  * Promedio de precisi√≥n
  * Aciertos totales
  * Errores totales

DECISI√ìN REQUERIDA:
1. ¬øA qu√© nivel bajar? FACIL, INTERMEDIO o DIFICIL (raramente)
2. ¬øQu√© velocidad usar en ESE nivel? (ajustar seg√∫n frustraci√≥n)

VELOCIDADES NORMALES DE REFERENCIA:
- FACIL: 3.0
- INTERMEDIO: 4.0
- DIFICIL: 5.0

GU√çA PARA LA IA:
- Si <30% aciertos ‚Üí FACIL, velocidad 2.5-3.0 (reducir frustraci√≥n)
- Si 30-60% aciertos ‚Üí INTERMEDIO, velocidad 3.5-4.0
- Si >60% aciertos ‚Üí DIFICIL, velocidad 4.5-5.0 (estuvo cerca)
- Reducir velocidad si precisi√≥n <50% o muchos errores

--------------------------------------------------------------------------------
FORMATO JSON DE RESPUESTA ESPERADO
--------------------------------------------------------------------------------

{
  "nivel_recomendado": "facil",
  "razonamiento_breve": "Tuvo X% aciertos, frustraci√≥n alta",
  "velocidad_ajustada": 2.5
}

CAMPOS:
- nivel_recomendado: "facil" | "intermedio" | "dificil"
- razonamiento_breve: Texto corto explicando la decisi√≥n
- velocidad_ajustada: N√∫mero decimal entre 2.0 y 6.0

--------------------------------------------------------------------------------
PROCESAMIENTO DE LA RESPUESTA
--------------------------------------------------------------------------------

1. Se extrae el JSON de la respuesta de texto de Gemini
2. Se valida que contenga los 3 campos requeridos
3. Se guardan temporalmente:
   - nivel_recomendado ‚Üí para decidir el siguiente nivel
   - velocidad_ajustada ‚Üí se aplica en la configuraci√≥n del nivel
4. Se genera el plan de sesi√≥n con estos par√°metros ajustados

FALLBACK (si falla Gemini):
- An√°lisis simple sin IA basado en porcentaje:
  * <30% ‚Üí FACIL
  * 30-60% ‚Üí INTERMEDIO
  * >60% ‚Üí DIFICIL


================================================================================
üî§ JUEGO 2: FORMACI√ìN DE PALABRAS (ABECEDARIO)
================================================================================

MODELO IA UTILIZADO: Gemini 2.5 Flash Lite

ESTRATEGIA H√çBRIDA DE AHORRO:
- Niveles FACIL e INTERMEDIO: Usa JSON local (palabras predefinidas) ‚Üí $0
- Nivel DIFICIL: Usa IA con sistema de BATCH (lotes de 20 palabras)
- Ahorro: 95% en costos de API

--------------------------------------------------------------------------------
PROMPT ENVIADO A GEMINI
--------------------------------------------------------------------------------

Contexto: "Eres un terapeuta cognitivo. Genera 20 PALABRAS DIFERENTES en 
espa√±ol para un juego de memoria adaptativo."

DATOS ENVIADOS:
- NIVEL ACTUAL: DIFICIL
  * Descripci√≥n: Palabras m√°s complejas pero conocidas
  * Longitud: 5-7 letras
  * Letras distractoras: 0-1

- RENDIMIENTO DEL USUARIO (√∫ltimas sesiones):
  * Total sesiones
  * Tasa de √©xito global (%)
  * Precisi√≥n reciente (%)
  * Promedio de errores
  * Estado actual (razonamiento del sistema)

- PALABRAS YA USADAS: Lista de palabras recientes (NO REPETIR)

INSTRUCCIONES PARA ADAPTAR DIFICULTAD:
- Si precisi√≥n reciente <50%: Usa palabras M√ÅS COMUNES del d√≠a a d√≠a
- Si precisi√≥n 50-80%: Usa palabras comunes con ligera complejidad
- Si precisi√≥n >80%: Puedes usar palabras conocidas m√°s desafiantes

REGLAS ESTRICTAS:
- Palabras apropiadas para adultos mayores
- TODAS LAS LETRAS EN MAY√öSCULAS (pueden tener acentos y √±)
- Letras distractoras tambi√©n en MAY√öSCULAS
- NO REPETIR palabras ya usadas
- Cada palabra con pista clara sin revelar la palabra
- Ajustar complejidad seg√∫n precisi√≥n reciente
- Formato JSON v√°lido

--------------------------------------------------------------------------------
FORMATO JSON DE RESPUESTA ESPERADO (BATCH)
--------------------------------------------------------------------------------

{
  "palabras": [
    {
      "palabra_objetivo": "JARD√çN",
      "letras_distractoras": ["L", "M"],
      "pista_contextual": "Espacio verde con plantas"
    },
    {
      "palabra_objetivo": "COCINA",
      "letras_distractoras": ["T", "R"],
      "pista_contextual": "Lugar donde se prepara comida"
    }
    ... (20 palabras en total)
  ]
}

CAMPOS POR PALABRA:
- palabra_objetivo: String en MAY√öSCULAS (5-7 letras)
- letras_distractoras: Array de 0-1 letras en MAY√öSCULAS
- pista_contextual: String con pista sin revelar la palabra

--------------------------------------------------------------------------------
PROCESAMIENTO DE LA RESPUESTA
--------------------------------------------------------------------------------

1. Se extrae el JSON de la respuesta
2. Se valida que contenga el array "palabras"
3. Para cada palabra se valida:
   - Tiene los 3 campos requeridos
   - palabra_objetivo se convierte a MAY√öSCULAS (forzado)
   - letras_distractoras se convierten a MAY√öSCULAS (forzado)
4. Las palabras v√°lidas se guardan en un BUFFER en memoria
5. Cada solicitud de palabra consume una del buffer
6. Cuando el buffer se vac√≠a, se genera un nuevo lote de 20

RESULTADO:
- Buffer de 20 palabras = 1 llamada a API
- Sin buffer = 20 llamadas a API
- AHORRO: 95% de llamadas


================================================================================
üé® JUEGO 3: TREN DE COLORES
================================================================================

MODELO IA UTILIZADO: Gemini 1.5 Flash

USO DE IA:
- Se usa SOLO para casos ambiguos (precisi√≥n entre 50-85%)
- Casos obvios (<50% o >85%) usan l√≥gica determinista

--------------------------------------------------------------------------------
PROMPT ENVIADO A GEMINI
--------------------------------------------------------------------------------

Contexto: "Juego cognitivo adultos mayores."

DATOS ENVIADOS (PROMPT ULTRA-COMPACTO):
- Precisi√≥n: XX%
- Velocidad actual: X.X

DECISI√ìN REQUERIDA:
"Decide: si mejora tendencia‚Üísubir, si errores frecuentes‚Üímantener/bajar."

NOTA: Este es un prompt EXTREMADAMENTE optimizado para reducir tokens.

--------------------------------------------------------------------------------
FORMATO JSON DE RESPUESTA ESPERADO
--------------------------------------------------------------------------------

{
  "d": "up" | "down" | "keep",
  "r": "raz√≥n corta"
}

CAMPOS (ultra-abreviados):
- d (decision): "up" (subir) | "down" (bajar) | "keep" (mantener)
- r (reason): Texto breve explicando la decisi√≥n

MAPEO DE DECISIONES:
- "up" ‚Üí "increase_difficulty"
- "down" ‚Üí "decrease_difficulty"
- "keep" ‚Üí "maintain"

--------------------------------------------------------------------------------
PROCESAMIENTO DE LA RESPUESTA
--------------------------------------------------------------------------------

1. Se extrae el JSON (eliminando markdown si existe)
2. Se mapea la decisi√≥n:
   - "up" ‚Üí Incrementar velocidad +0.3 (l√≠mite: 6.0)
   - "down" ‚Üí Decrementar velocidad -0.5 (l√≠mite: 3.0)
   - "keep" ‚Üí Mantener velocidad actual
3. Se construye nueva configuraci√≥n con:
   - Velocidad ajustada (ADAPTATIVO)
   - Spawn rate ajustado (ADAPTATIVO)
   - Total de trenes (FIJO seg√∫n dificultad)
   - Cantidad de colores (FIJO seg√∫n dificultad)

VALORES FIJOS POR NIVEL:
- Easy: 6 trenes, 3 colores
- Medium: 8 trenes, 4 colores
- Hard: 10 trenes, 5 colores

L√ìGICA CL√ÅSICA (sin IA):
- Timeout ‚Üí Siempre bajar
- Precisi√≥n >=85% ‚Üí Subir
- Precisi√≥n <50% ‚Üí Bajar
- Precisi√≥n 50-85% ‚Üí Mantener (o usar IA si disponible)


================================================================================
üÉè JUEGO 4: MEMORIA CON CARTAS (MEMORY GAME)
================================================================================

MODELO IA UTILIZADO: Gemini 2.0 Flash Exp

USO DE IA:
- Se intenta usar IA para an√°lisis completo
- Si falla, usa l√≥gica determinista robusta (fallback)

--------------------------------------------------------------------------------
PROMPT ENVIADO A GEMINI
--------------------------------------------------------------------------------

Contexto: "Act√∫a como un sistema experto de ajuste de dificultad para un juego
de memoria terap√©utico para adultos mayores."

DATOS DE LA SESI√ìN:
- Dificultad actual
- Resultado: VICTORIA o DERROTA (Tiempo Agotado)
- Pares encontrados: X de Y
- Intentos (flips): Z
- Tiempo usado: Ts (L√≠mite: TLs)
- Precisi√≥n: X%

REGLAS DE AJUSTE:
1. SI PERDI√ì (Tiempo agotado):
   - DEBE facilitar el juego
   - Prioridad: Aumentar time_limit (+15-30s) O reducir total_pairs
   - Nunca aumentar dificultad si perdi√≥

2. SI GAN√ì (Completado):
   - Evaluar desempe√±o (Velocidad y Precisi√≥n)
   - Si fue MUY F√ÅCIL ‚Üí Aumentar dificultad
   - Si fue NORMAL ‚Üí Mantener o ajustes leves
   - Si le cost√≥ mucho ‚Üí Mantener o facilitar ligeramente

NIVELES DISPONIBLES (Referencia):
{
  "tutorial": {total_pairs: 3, grid_size: "2x3", time_limit: 60, ...},
  "easy": {total_pairs: 4, grid_size: "2x4", time_limit: 90, ...},
  "medium": {total_pairs: 6, grid_size: "3x4", time_limit: 120, ...},
  "hard": {total_pairs: 8, grid_size: "2x8", time_limit: 150, ...},
  "expert": {total_pairs: 10, grid_size: "4x5", time_limit: 180, ...},
  "master": {total_pairs: 12, grid_size: "3x8", time_limit: 200, ...}
}

--------------------------------------------------------------------------------
FORMATO JSON DE RESPUESTA ESPERADO
--------------------------------------------------------------------------------

{
  "analysis": {
    "decision": "increase" | "decrease" | "maintain",
    "reason": "Explicaci√≥n corta para el terapeuta",
    "score": 1-10 (Calidad del juego),
    "metrics": {
      "memory": "low" | "medium" | "high",
      "speed": "slow" | "normal" | "fast",
      "accuracy": "low" | "medium" | "high"
    }
  },
  "new_config": {
    "difficulty_label": "nombre_del_nivel",
    "total_pairs": int,
    "grid_size": "FxC" (ej: "3x4"),
    "time_limit": int,
    "memorization_time": int
  }
}

CAMPOS:
- decision: "increase" (subir) | "decrease" (bajar) | "maintain" (mantener)
- reason: Explicaci√≥n breve para el terapeuta
- score: Calificaci√≥n de 1-10 del desempe√±o
- metrics: Evaluaci√≥n cualitativa (memory, speed, accuracy)
- new_config: Configuraci√≥n completa para la pr√≥xima sesi√≥n

--------------------------------------------------------------------------------
PROCESAMIENTO DE LA RESPUESTA
--------------------------------------------------------------------------------

1. Se limpia el JSON (eliminar markdown ```json ... ```)
2. Se valida la estructura completa
3. Si falta grid_size, se calcula autom√°ticamente seg√∫n total_pairs
4. Se detectan campos cambiados (total_pairs, time_limit, difficulty)
5. Se retorna an√°lisis completo con:
   - Decisi√≥n de ajuste
   - Raz√≥n detallada
   - Resumen de cambios
   - Nueva configuraci√≥n
   - Evaluaci√≥n de desempe√±o

FALLBACK (L√≥gica Determinista):

C√ÅLCULO DE SCORE:
- Base (0-6 puntos): Precisi√≥n (accuracy/100 * 6)
- Bonus velocidad (0-2 puntos):
  * Muy r√°pido (<50% tiempo): +2.0
  * R√°pido (50-70%): +1.5
  * Normal (70-90%): +1.0
  * Lento (>90%): +0.5
- Bonus completar (0-2 puntos): 
  * Completado: +2.0
  * No completado: 0
- Score final: min(10, suma de puntos)

M√âTRICAS CUALITATIVAS:
- Memory: high (>=80%), medium (>=50%), low (<50%)
- Speed: fast (<50% tiempo), normal (50-80%), slow (>80%)
- Accuracy: high (>=80%), medium (>=50%), low (<50%)

L√ìGICA DE AJUSTE:
- Si PERDI√ì: decrease (bajar nivel o dar m√°s tiempo)
- Si GAN√ì con alta precisi√≥n y r√°pido (>80% y <60% tiempo): increase
- Si GAN√ì con baja precisi√≥n (<50%): maintain (para practicar)
- Si GAN√ì normal: maintain

MICRO-AJUSTES PROGRESIVOS (si se mantiene 3+ sesiones):
- Si precisi√≥n <65%: +5s, +10s, +15s en time_limit
- Si precisi√≥n >=75%: -3s, -6s, -10s en time_limit
- Ajustes en memorization_time (¬±1s)


================================================================================
üìä COMPARACI√ìN DE ESTRATEGIAS DE IA POR JUEGO
================================================================================

+------------------+-------------------+------------------+--------------------+
| JUEGO            | MODELO GEMINI     | CU√ÅNDO USA IA    | ESTRATEGIA AHORRO  |
+------------------+-------------------+------------------+--------------------+
| Paseo            | 2.5 Flash         | Solo derrota     | L√≥gica simple 95%  |
|                  |                   | en DIFICIL       | del tiempo         |
+------------------+-------------------+------------------+--------------------+
| Abecedario       | 2.5 Flash Lite    | Solo nivel       | Batch de 20        |
|                  |                   | DIFICIL          | palabras (95%‚Üì)    |
+------------------+-------------------+------------------+--------------------+
| Tren Colores     | 1.5 Flash         | Casos ambiguos   | IA solo 50-85%     |
|                  |                   | (50-85%)         | precisi√≥n          |
+------------------+-------------------+------------------+--------------------+
| Memoria          | 2.0 Flash Exp     | Siempre intenta  | Fallback robusto   |
|                  |                   | (con fallback)   | si falla IA        |
+------------------+-------------------+------------------+--------------------+

CARACTER√çSTICAS COMUNES:
- Todos extraen JSON de respuestas de texto
- Todos tienen fallback/l√≥gica cl√°sica por seguridad
- Todos env√≠an datos de rendimiento reciente
- Todos reciben configuraci√≥n para pr√≥xima sesi√≥n


================================================================================
üîë ELEMENTOS CLAVE DE DISE√ëO DE PROMPTS
================================================================================

1. CONTEXTO CLARO:
   - Siempre se especifica que es para adultos mayores
   - Se da rol a la IA ("terapeuta cognitivo", "sistema experto")

2. DATOS ESTRUCTURADOS:
   - Se env√≠an m√©tricas cuantificables (precisi√≥n, tiempo, errores)
   - Se incluye historial reciente cuando es relevante

3. GU√çAS EXPL√çCITAS:
   - Se dan umbrales num√©ricos (ej: <30%, 50-85%, >85%)
   - Se especifican acciones seg√∫n cada caso

4. FORMATO JSON ESTRICTO:
   - Se solicita JSON v√°lido
   - Se da ejemplo del formato esperado
   - Se especifican nombres exactos de campos

5. OPTIMIZACI√ìN DE TOKENS:
   - Paseo: Prompt detallado pero solo para casos cr√≠ticos
   - Abecedario: Batch para reducir llamadas
   - Tren: Prompt ultra-compacto para casos ambiguos
   - Memoria: Prompt completo pero con fallback robusto

6. VALIDACI√ìN DEFENSIVA:
   - Siempre se limpia la respuesta (eliminar markdown)
   - Siempre se valida estructura JSON
   - Siempre se fuerzan tipos de datos (MAY√öSCULAS, n√∫meros)
   - Siempre hay plan B si la IA falla


================================================================================
üìà FLUJO GENERAL DE USO DE IA
================================================================================

Para todos los juegos:

1. PREPARACI√ìN:
   - Recopilar datos de la sesi√≥n actual
   - Obtener historial relevante (√∫ltimas 3-10 sesiones)
   - Calcular m√©tricas (precisi√≥n, tiempo, errores)

2. DECISI√ìN DE USAR IA:
   - Paseo: Solo si perdi√≥ en DIFICIL
   - Abecedario: Solo nivel DIFICIL (batch)
   - Tren: Solo precisi√≥n 50-85%
   - Memoria: Siempre intenta (con fallback)

3. CONSTRUCCI√ìN DEL PROMPT:
   - Contexto del juego y objetivo terap√©utico
   - Datos cuantitativos del rendimiento
   - Gu√≠as/reglas para la decisi√≥n
   - Formato JSON esperado con ejemplo

4. ENV√çO Y RECEPCI√ìN:
   - Llamada al modelo de Gemini correspondiente
   - Recepci√≥n de texto con JSON embebido

5. PARSEO Y VALIDACI√ìN:
   - Extraer JSON del texto (eliminar markdown)
   - Validar estructura y campos requeridos
   - Normalizar datos (MAY√öSCULAS, redondeos)
   - Aplicar l√≠mites (min/max de velocidad, tiempo, etc.)

6. APLICACI√ìN:
   - Configurar par√°metros para pr√≥xima sesi√≥n
   - Guardar decisi√≥n de IA en base de datos
   - Retornar configuraci√≥n al frontend

7. FALLBACK (si falla):
   - Usar l√≥gica determinista cl√°sica
   - Registrar error pero continuar servicio
   - Garantizar experiencia sin interrupciones


================================================================================
Documento generado: 2026-01-20
================================================================================
